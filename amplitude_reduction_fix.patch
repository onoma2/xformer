diff --git a/src/apps/sequencer/engine/CurveTrackEngine.cpp b/src/apps/sequencer/engine/CurveTrackEngine.cpp
index 456def1..789abc2 100644
--- a/src/apps/sequencer/engine/CurveTrackEngine.cpp
+++ b/src/apps/sequencer/engine/CurveTrackEngine.cpp
@@ -14,6 +14,48 @@ static Random rng;
 
 static float applyDjFilter(float input, float &lpfState, float control, float resonance) {
     // 1. Dead zone
+    if (control > -0.02f && control < 0.02f) {
+        return input;
+    }
+
+    // Pre-emphasis: boost input based on filter settings to compensate for expected loss
+    float pre_emphasis = 1.0f;
+    if (control > 0.0f) { // HPF mode
+        // For HPF, we may lose low-frequency content, so slightly boost input
+        pre_emphasis = 1.0f + std::abs(control) * 0.2f;
+    } else { // LPF mode
+        // For LPF, we may attenuate high frequencies, so boost input appropriately
+        pre_emphasis = 1.0f + std::abs(control) * 0.3f;
+    }
+    
+    float pre_emphasized_input = input * pre_emphasis;
+
+    float alpha;
+    if (control < 0.f) { // LPF Mode (knob left)
+        alpha = 1.f - std::abs(control);
+    } else { // HPF Mode (knob right)
+        alpha = 0.1f + std::abs(control) * 0.85f;
+    }
+    alpha = clamp(alpha * alpha, 0.005f, 0.95f);
+
+    // Add resonance (filter-to-filter feedback)
+    float feedback = resonance * 4.f;
+    float feedback_input = pre_emphasized_input - lpfState * feedback;
+
+    // Update the internal LPF state
+    lpfState = lpfState + alpha * (feedback_input - lpfState);
+
+    float filtered_output;
+    // 2. Correct LPF/HPF mapping
+    if (control < 0.f) { // LPF
+        filtered_output = lpfState;
+    } else { // HPF
+        filtered_output = pre_emphasized_input - lpfState;
+    }
+    
+    // Post-emphasis compensation to prevent excessive amplification
+    float post_compensation = 1.0f / pre_emphasis;
+    return filtered_output * post_compensation;
+}
+
+static float applyDjFilterOriginal(float input, float &lpfState, float control, float resonance) {
+    // 1. Dead zone
     if (control > -0.02f && control < 0.02f) {
         return input;
     }
@@ -44,6 +86,50 @@ static float applyDjFilter(float input, float &lpfState, float control, float r
     }
 }
 
+// Enhanced wavefolder with amplitude tracking and compensation
+static float applyWavefolderWithAmplitudeCompensation(float input, float fold, float gain, float symmetry, 
+                                                      float &amplitude_tracker, float compensation_factor) {
+    // map from [0, 1] to [-1, 1]
+    float bipolar_input = (input * 2.f) - 1.f;
+    // apply symmetry
+    float biased_input = bipolar_input + symmetry;
+    // apply gain
+    float gained_input = biased_input * gain;
+    // apply folding using sine function
+    float fold_count = 1.f + fold * 8.f;
+    float folded_output = sinf(gained_input * M_PI * fold_count);
+    
+    // Track the amplitude of the folded signal
+    float signal_amplitude = std::abs(folded_output);
+    amplitude_tracker = 0.9f * amplitude_tracker + 0.1f * signal_amplitude; // Smooth tracking
+    
+    // map back from [-1, 1] to [0, 1]
+    float result = (folded_output + 1.f) * 0.5f;
+    
+    // Apply amplitude compensation based on the tracked amplitude
+    if (amplitude_tracker > 0.01f) { // Avoid division by zero
+        float desired_amplitude = 0.5f; // Target amplitude
+        float compensation = desired_amplitude / amplitude_tracker;
+        // Limit compensation to prevent excessive amplification
+        compensation = std::min(compensation, 3.0f); // Maximum 3x amplification
+        result = 0.5f + (result - 0.5f) * compensation * compensation_factor;
+    }
+    
+    return clamp(result, 0.0f, 1.0f);
+}
+
+// Alternative: Adaptive gain based on filter settings
+static float applyWavefolderWithAdaptiveGain(float input, float fold, float gain, float symmetry, 
+                                           float filter_control, float &amplitude_tracker) {
+    // Calculate adaptive gain based on filter settings
+    float filter_compensation = 1.0f;
+    if (std::abs(filter_control) > 0.3f) {
+        // More compensation needed for extreme filter settings
+        filter_compensation = 1.0f + std::abs(filter_control) * 0.5f;
+    }
+    
+    // Adjust gain based on filter compensation
+    float adjusted_gain = gain * filter_compensation;
+    
+    // Apply original wavefolder algorithm with adjusted gain
+    return applyWavefolder(input, fold, adjusted_gain, symmetry);
+}
+
 static float applyWavefolder(float input, float fold, float gain, float symmetry) {
     // map from [0, 1] to [-1, 1]
     float bipolar_input = (input * 2.f) - 1.f;
@@ -285,6 +371,8 @@ void CurveTrackEngine::updateOutput(uint32_t relativeTick, uint32_t divisor) {
         float fold = _curveTrack.wavefolderFold();
         float shaperFeedback = _curveTrack.foldF();
 
+        float filterControl = _curveTrack.djFilter();
+
         // 3. Apply shaper feedback (filter-to-fold)
         float folderInput = value + _feedbackState * shaperFeedback;
 
@@ -292,12 +379,16 @@ void CurveTrackEngine::updateOutput(uint32_t relativeTick, uint32_t divisor) {
             float gain = _curveTrack.wavefolderGain();
             float symmetry = _curveTrack.wavefolderSymmetry();
             // Apply exponential curve to fold control for better resolution
-            float fold_exp = fold * fold;
-            folderInput = applyWavefolder(folderInput, fold_exp, gain, symmetry);
+            float fold_exp = fold * fold;
+            // Use enhanced wavefolder with adaptive gain based on filter settings
+            folderInput = applyWavefolderWithAdaptiveGain(folderInput, fold_exp, gain, symmetry, filterControl, _amplitudeTracker);
         }
 
         // 5. Denormalize to voltage
         float voltage = range.denormalize(folderInput);
+        
+        // Store original voltage for potential use in amplitude tracking
 
         // 6. Apply DJ Filter
         float filterControl = _curveTrack.djFilter();
@@ -326,7 +417,7 @@ void CurveTrackEngine::updateOutput(uint32_t relativeTick, uint32_t divisor) {
         float filterResonance = _curveTrack.filterF();
         // The filter is always active to calculate state, but only applied if control is not 0
         voltage = applyDjFilter(voltage, _lpfState, filterControl, filterResonance);
-        
+
         // 7. Update feedback state for next tick
         _feedbackState = voltage;
 
@@ -435,6 +526,7 @@ void CurveTrackEngine::updateRecording(uint32_t relativeTick, uint32_t divisor)
 
 // Additional member variables to be added to CurveTrackEngine class in header
 // float _amplitudeTracker;  // For tracking signal amplitude for compensation
+// float _amplitudeTracker = 0.5f;  // Initialize in constructor/reset methods