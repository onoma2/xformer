#include "DiscreteMapSequencePage.h"

#include "Pages.h"

#include "ui/MatrixMap.h"
#include "ui/LedPainter.h"
#include "ui/painters/WindowPainter.h"

#include "model/Routing.h"
#include "model/Types.h"
#include "model/Scale.h"

#include "core/math/Math.h"
#include "core/utils/StringBuilder.h"

enum class ContextAction {
    Init,
    Copy,
    Paste,
    Random,
    Route,
    Last
};

static const ContextMenuModel::Item contextMenuItems[] = {
    { "INIT" },
    { "COPY" },
    { "PASTE" },
    { "RAND" },
    { "ROUTE" },
};

DiscreteMapSequencePage::DiscreteMapSequencePage(PageManager &manager, PageContext &context) :
    BasePage(manager, context)
{}

void DiscreteMapSequencePage::enter() {
    refreshPointers();
}

void DiscreteMapSequencePage::exit() {
}

void DiscreteMapSequencePage::refreshPointers() {
    _sequence = nullptr;
    _enginePtr = nullptr;

    if (_project.selectedTrack().trackMode() != Track::TrackMode::DiscreteMap) {
        return;
    }

    _sequence = &_project.selectedDiscreteMapSequence();

    auto &trackEngine = _engine.trackEngine(_project.selectedTrackIndex());
    if (trackEngine.trackMode() == Track::TrackMode::DiscreteMap) {
        _enginePtr = static_cast<DiscreteMapTrackEngine *>(&trackEngine);
    }
}

void DiscreteMapSequencePage::draw(Canvas &canvas) {
    refreshPointers();
    WindowPainter::clear(canvas);
    WindowPainter::drawHeader(canvas, _model, _engine, "DMAP");

    FixedStringBuilder<32> headerName;
    headerName(Track::trackModeName(_project.selectedTrack().trackMode()));
    headerName(_editMode == EditMode::NoteValue ? ": NOTE" : ": THR");
    headerName(" %d/4", _section + 1);
    WindowPainter::drawActiveFunction(canvas, headerName);

    if (!_sequence) {
        canvas.drawText(8, 24, "Select a DiscreteMap track");
        WindowPainter::drawFooter(canvas);
        return;
    }

    drawThresholdBar(canvas);
    drawStageInfo(canvas);
    drawFooter(canvas);
}

void DiscreteMapSequencePage::drawThresholdBar(Canvas &canvas) {
    const int barX = 8;
    const int barY = 12;
    const int barW = 240;
    const int barLineY = barY + 8; // Baseline position

    // Draw thin 2px horizontal baseline (Color::Low)
    canvas.setColor(Color::Low);
    canvas.hline(barX, barLineY, barW);
    canvas.hline(barX, barLineY + 1, barW); // 2px thick

    // Draw threshold markers growing upward from baseline
    for (int i = 0; i < DiscreteMapSequence::StageCount; ++i) {
        const auto &stage = _sequence->stage(i);
        if (stage.direction() == DiscreteMapSequence::Stage::TriggerDir::Off) {
            continue;
        }

        float norm = clamp(getThresholdNormalized(i), 0.f, 1.f);
        int x = barX + int(norm * barW);

        bool selected = (_selectionMask & (1U << i)) != 0;
        bool active = _enginePtr && _enginePtr->activeStage() == i;

        // Determine marker height based on state
        int markerHeight = active ? 8 : (selected ? 6 : 4);

        canvas.setColor(active ? Color::Bright : (selected ? Color::Medium : Color::Low));
        canvas.vline(x, barLineY - markerHeight, markerHeight); // Grow upward
        canvas.vline(x, barLineY - markerHeight, markerHeight); // 2px wide
    }

    // Draw input cursor growing upward from baseline
    if (_enginePtr) {
        float inputNorm = clamp((_enginePtr->currentInput() - rangeMin()) / (rangeMax() - rangeMin()), 0.f, 1.f);
        int cursorX = barX + int(inputNorm * barW);
        const int cursorHeight = 8;

        canvas.setColor(Color::Bright);
        canvas.vline(cursorX, barLineY - cursorHeight, cursorHeight); // Grow upward
    }
}

void DiscreteMapSequencePage::drawStageInfo(Canvas &canvas) {
    const int y = 30;
    const int spacing = 30;

    // Draw row selection brackets
    // Row 2 (y+8): Threshold
    // Row 3 (y+16): Note
    int bracketY = (_editMode == EditMode::NoteValue) ? y + 16 : y + 8;
    int bracketH = 6;
    canvas.setColor(Color::Bright);
    canvas.vline(8, bracketY - 4, bracketH);
    canvas.vline(246, bracketY - 4, bracketH);

    int stepOffset = _section * 8;
    for (int i = 0; i < 8; ++i) {
        int stageIndex = stepOffset + i;
        if (stageIndex >= DiscreteMapSequence::StageCount) break;

        const auto &stage = _sequence->stage(stageIndex);
        int x = 8 + i * spacing + 11; // Centered (+11)

        bool selected = (_selectionMask & (1U << stageIndex)) != 0;
        bool active = _enginePtr && _enginePtr->activeStage() == stageIndex;

        // Row 1: Direction (Top)
        canvas.setColor(active ? Color::Bright : (selected ? Color::Medium : Color::Low));
        char dirChar = '-';
        switch (stage.direction()) {
        case DiscreteMapSequence::Stage::TriggerDir::Rise: dirChar = '^'; break;
        case DiscreteMapSequence::Stage::TriggerDir::Fall: dirChar = 'v'; break;
        case DiscreteMapSequence::Stage::TriggerDir::Off:  dirChar = '-'; break;
        }
        char dirStr[2] = { dirChar, 0 };
        canvas.drawText(x, y, dirStr); // Center aligned x

        // Row 2: Threshold
        canvas.setColor(active ? Color::Bright : (selected ? Color::Medium : Color::Low));
        FixedStringBuilder<6> thresh("%+d", stage.threshold());
        // Adjust x for multi-digit numbers if needed?
        // FixedStringBuilder doesn't auto-center.
        // 30px width. "+127" is 4 chars * 7px = 28px.
        // "+11" offset centers 1 char.
        // If x is center of column?
        // My code: x = 8 + i*30 + 11.
        // This makes x the START of the text.
        // If I draw "+127" at x, it might spill.
        // The diff used: int x = barX + i * segmentWidth + segmentWidth / 2 - 4; (-4 to center text?)
        // If I use +11 (approx 30/2 - 4), it's close.
        // But for "+127", width is 24-28.
        // x should be center - width/2.
        // I'll stick to x as start position for now, assuming 2-3 chars average.
        canvas.drawText(x - 4, y + 8, thresh); // Shift left for numbers?

        // Row 3: Note
        if (stage.direction() != DiscreteMapSequence::Stage::TriggerDir::Off || selected) {
            FixedStringBuilder<8> name;
            const Scale &scale = _sequence->selectedScale(_project.selectedScale());

            float volts = scale.noteToVolts(stage.noteIndex());
            if (scale.isChromatic()) {
                volts += _sequence->rootNote() * (1.f / 12.f);
            }
            int midiNote = int(volts * 12.f) + 12;

            Types::printMidiNote(name, midiNote);

            canvas.setColor(active ? Color::Bright : (selected ? Color::Medium : Color::Low));
            canvas.drawText(x - 4, y + 16, name); // Shift left
        } else {
            canvas.setColor(Color::Low);
            canvas.drawText(x - 4, y + 16, "--");
        }
    }
}

void DiscreteMapSequencePage::drawFooter(Canvas &canvas) {
    const char *clockSource = "INT";
    switch (_sequence->clockSource()) {
    case DiscreteMapSequence::ClockSource::Internal: clockSource = "SAW"; break;
    case DiscreteMapSequence::ClockSource::InternalTriangle: clockSource = "TRI"; break;
    case DiscreteMapSequence::ClockSource::External: clockSource = "EXT"; break;
    }

    const char *fnLabels[5] = {
        clockSource,
        nullptr,
        _sequence->thresholdMode() == DiscreteMapSequence::ThresholdMode::Position ? "POS" : "LEN",
        _sequence->loop() ? "LOOP" : "ONCE",
        nullptr
    };

    WindowPainter::drawFooter(canvas, fnLabels, pageKeyState(), -1);
}

void DiscreteMapSequencePage::updateLeds(Leds &leds) {
    if (!_sequence) {
        return;
    }

    int stepOffset = _section * 8;

    // Direction (Top Row: 8-15)
    for (int i = 0; i < 8; ++i) {
        int stageIndex = stepOffset + i;
        if (stageIndex >= DiscreteMapSequence::StageCount) break;

        const auto &stage = _sequence->stage(stageIndex);
        auto ledIndex = MatrixMap::fromStep(i + 8);
        switch (stage.direction()) {
        case DiscreteMapSequence::Stage::TriggerDir::Rise:
            leds.set(ledIndex, false, true);
            break;
        case DiscreteMapSequence::Stage::TriggerDir::Fall:
            leds.set(ledIndex, true, false);
            break;
        case DiscreteMapSequence::Stage::TriggerDir::Off:
            leds.set(ledIndex, false, false);
            break;
        }
    }

    // Selection/Active (Bottom Row: 0-7)
    for (int i = 0; i < 8; ++i) {
        int stageIndex = stepOffset + i;
        if (stageIndex >= DiscreteMapSequence::StageCount) break;

        bool selected = (_selectionMask & (1U << stageIndex)) != 0;
        bool active = _enginePtr && _enginePtr->activeStage() == stageIndex;
        auto ledIndex = MatrixMap::fromStep(i);
        if (selected) {
            leds.set(ledIndex, true, true);
        } else if (active) {
            leds.set(ledIndex, false, true);
        } else {
            leds.set(ledIndex, false, false);
        }
    }
}

void DiscreteMapSequencePage::keyDown(KeyEvent &event) {
    const auto &key = event.key();
    _shiftHeld = key.shiftModifier();
    refreshPointers();

    if (key.isContextMenu()) {
        contextShow();
        event.consume();
        return;
    }

    if (key.pageModifier() || !_sequence) {
        return;
    }

    if (key.isStep()) {
        int stepOffset = _section * 8;
        int idx = key.step();
        if (idx < 8) {
            _stepKeysHeld |= (1 << idx);
            handleTopRowKey(stepOffset + idx, key.shiftModifier());
        } else {
            handleBottomRowKey(stepOffset + idx - 8);
        }
        event.consume();
        return;
    }

    if (key.isFunction()) {
        handleFunctionKey(key.function());
        event.consume();
    }
}

void DiscreteMapSequencePage::keyUp(KeyEvent &event) {
    if (event.key().isStep()) {
        int idx = event.key().step();
        // If it was a Selection Button (Bottom Row: 0-7)
        if (idx < 8) {
            _stepKeysHeld &= ~(1 << idx);
        }
    }
    _shiftHeld = event.key().shiftModifier();
}

void DiscreteMapSequencePage::keyPress(KeyPressEvent &event) {
    const auto &key = event.key();
    if (key.isContextMenu()) {
        contextShow();
        event.consume();
        return;
    }

    if (key.isEncoder()) {
        _editMode = (_editMode == EditMode::NoteValue) ? EditMode::Threshold : EditMode::NoteValue;
        event.consume();
        return;
    }

    if (key.isLeft()) {
        _section = std::max(0, _section - 1);
        event.consume();
    }
    if (key.isRight()) {
        _section = std::min(3, _section + 1);
        event.consume();
    }
}

void DiscreteMapSequencePage::encoder(EncoderEvent &event) {
    if (!_sequence) {
        return;
    }

    int delta = event.value();

    for (int i = 0; i < DiscreteMapSequence::StageCount; ++i) {
        if (!(_selectionMask & (1U << i))) {
            continue;
        }

        switch (_editMode) {
        case EditMode::Threshold: {
            auto &s = _sequence->stage(i);
            int step = _shiftHeld ? 1 : 8;
            s.setThreshold(clamp(s.threshold() + delta * step, -99, 99));
            if (_enginePtr) {
                _enginePtr->invalidateThresholds();
            }
            break;
        }
        case EditMode::NoteValue: {
            auto &s = _sequence->stage(i);
            int step = _shiftHeld ? 12 : 1;
            s.setNoteIndex(s.noteIndex() + delta * step);
            break;
        }
        default:
            break;
        }
    }
}

void DiscreteMapSequencePage::handleTopRowKey(int idx, bool shift) {
    if (shift) {
        _editMode = EditMode::NoteValue;
    } else {
        // Persist current mode, or default to Threshold if None
        if (_editMode == EditMode::None) {
            _editMode = EditMode::Threshold;
        }
    }

    // Check if any OTHER selection key (0-7) is held
    // idx is logical index. Physical index is idx % 8.
    int physicalIdx = idx % 8;
    bool multiSelect = (_stepKeysHeld & 0xFF & ~(1 << physicalIdx)) != 0;

    if (multiSelect) {
        _selectionMask ^= (1U << idx); // Toggle
        if (_selectionMask == 0) _selectionMask = (1U << idx);
    } else {
        _selectionMask = (1U << idx); // Switch
    }

    _selectedStage = idx; // Update focus
}

void DiscreteMapSequencePage::handleBottomRowKey(int idx) {
    auto &stage = _sequence->stage(idx);

    switch (stage.direction()) {
    case DiscreteMapSequence::Stage::TriggerDir::Rise:
        stage.setDirection(DiscreteMapSequence::Stage::TriggerDir::Fall);
        break;
    case DiscreteMapSequence::Stage::TriggerDir::Fall:
        stage.setDirection(DiscreteMapSequence::Stage::TriggerDir::Off);
        break;
    case DiscreteMapSequence::Stage::TriggerDir::Off:
        stage.setDirection(DiscreteMapSequence::Stage::TriggerDir::Rise);
        break;
    }

    if (_enginePtr) {
        _enginePtr->invalidateThresholds();
    }
}

void DiscreteMapSequencePage::handleFunctionKey(int fnIndex) {
    switch (fnIndex) {
    case 0:
        _sequence->toggleClockSource();
        break;
    case 2:
        _sequence->toggleThresholdMode();
        if (_enginePtr) {
            _enginePtr->invalidateThresholds();
        }
        break;
    case 3:
        _sequence->toggleLoop();
        break;
    default:
        break;
    }
}

float DiscreteMapSequencePage::getThresholdNormalized(int stageIndex) const {
    const auto &stage = _sequence->stage(stageIndex);
    return (stage.threshold() + 100) / 200.f;
}

void DiscreteMapSequencePage::contextShow() {
    showContextMenu(ContextMenu(
        contextMenuItems,
        int(ContextAction::Last),
        [&] (int index) { contextAction(index); },
        [&] (int index) { return contextActionEnabled(index); }
    ));
}

void DiscreteMapSequencePage::contextAction(int index) {
    switch (ContextAction(index)) {
    case ContextAction::Init:
        if (_sequence) {
            _sequence->clear();
            if (_enginePtr) {
                _enginePtr->invalidateThresholds();
            }
            showMessage("INITIALIZED");
        }
        break;
    case ContextAction::Copy:
        _model.clipBoard().copyDiscreteMapSequence(*_sequence);
        showMessage("COPIED");
        break;
    case ContextAction::Paste:
        _model.clipBoard().pasteDiscreteMapSequence(*_sequence);
        if (_enginePtr) {
            _enginePtr->invalidateThresholds();
        }
        showMessage("PASTED");
        break;
    case ContextAction::Random:
        if (_sequence) {
            _sequence->randomize();
            if (_enginePtr) {
                _enginePtr->invalidateThresholds();
            }
            showMessage("SEQUENCE RANDOMIZED");
        }
        break;
    case ContextAction::Route:
        _manager.pages().top.editRoute(Routing::Target::Divisor, _project.selectedTrackIndex());
        break;
    case ContextAction::Last:
        break;
    }
}

bool DiscreteMapSequencePage::contextActionEnabled(int index) const {
    switch (ContextAction(index)) {
    case ContextAction::Paste:
        return _model.clipBoard().canPasteDiscreteMapSequence();
    case ContextAction::Random:
        return _sequence != nullptr;
    case ContextAction::Route:
        return true;
    default:
        return true;
    }
}
